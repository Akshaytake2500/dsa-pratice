class Solution {
    public int findDuplicate(int[] nums) {
// using linked list cycle method   [1,3,4,2,2]
        int slow=nums[0]; //1
        int fast=nums[0]; //1
    //Phase 1: Detect the cycle
        do{
            slow=nums[slow];
            fast=nums[nums[fast]];
        }while(slow!=fast);

    //Phase 2:find the entrance of the cycle
        slow=nums[0];   //--making slow to point at index 0 to iterate and check same element present with fast
        while(slow!=fast){
            slow=nums[slow];
            fast=nums[fast];
        }    
        return slow; //slow/fast both return the same element.

        // Using map method
        // Map<Integer,Integer> map=new HashMap<>();
        // for(int num:nums){
        // if(map.containsKey(num)){
        // return num;
        // }
        // map.put(num,1);
        // }
        // return -1;

        // Sort the array and check adjacent elements
        // Arrays.sort(nums); // 12234
        // for (int i = 0; i < nums.length - 1; i++) {
        // if (nums[i] == nums[i + 1]) {
        // return nums[i];
        // }
        // }
        // return -1;

        // Brute force
        // int count = 0;
        // for (int i = 0; i < nums.length; i++) {
        // for (int j = i + 1; j < nums.length; j++) {
        // if (nums[i] == nums[j]) {
        // return nums[i];
        // }
        // }
        // }
        // return -1;
    }
}
